<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>GO 零基础 step-by-step 写一个运行在 kubernetes 的服务 | zich 的 blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="GO 零基础 step-by-step 写一个运行在 kubernetes 的服务 | zich 的 blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="如果你用Go写过程序，就会发现用Go来写服务是很简单的事。比如说，只要几行代码就可以跑起来一个HTTP服务。但是如果想让服务在生产环境能运行起来，我们需要额外加一些东西。本文讨论服务如何能够在kubernets上运行起来。 文中所有的例子可以在这里（按标签分类），或者这里（按commit分类）找到。 第一步 最简单的服务从一个最简单的应用开始：main.go package main  impor">
<meta property="og:type" content="article">
<meta property="og:title" content="GO 零基础 step-by-step 写一个运行在 kubernetes 的服务">
<meta property="og:url" content="http://github.com/dongfengkuayue/2017/12/28/Write%20a%20Kubernetes-ready%20service%20from%20zero%20step-by-step/index.html">
<meta property="og:site_name" content="zich 的 blog">
<meta property="og:description" content="如果你用Go写过程序，就会发现用Go来写服务是很简单的事。比如说，只要几行代码就可以跑起来一个HTTP服务。但是如果想让服务在生产环境能运行起来，我们需要额外加一些东西。本文讨论服务如何能够在kubernets上运行起来。 文中所有的例子可以在这里（按标签分类），或者这里（按commit分类）找到。 第一步 最简单的服务从一个最简单的应用开始：main.go package main  impor">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-12-27T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-09T02:39:27.490Z">
<meta property="article:author" content="zich">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.2"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>zich</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/dongfengkuayue"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(3)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="旅游">
                        
                        旅游
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="GOLANG">
                        
                        GOLANG
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">
<input type="hidden" id="yelog_site_word_count" value="5.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>江浙</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 GOLANG "
           href="/2017/12/28/Write%20a%20Kubernetes-ready%20service%20from%20zero%20step-by-step/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GO 零基础 step-by-step 写一个运行在 kubernetes 的服务">GO 零基础 step-by-step 写一个运行在 kubernetes 的服务</span>
            <span class="post-date" title="2017-12-28 00:00:00">2017/12/28</span>
        </a>
        
        <a  class="全部文章 GOLANG "
           href="/2017/08/01/go_reflection/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GO reflection 理解">GO reflection 理解</span>
            <span class="post-date" title="2017-08-01 00:00:00">2017/08/01</span>
        </a>
        
        <a  class="全部文章 旅游 "
           href="/2017/07/26/jiangnan_tianchi_lvyou/"
           data-tag="江浙"
           data-author="" >
            <span class="post-title" title="江南天池游">江南天池游</span>
            <span class="post-date" title="2017-07-26 00:00:00">2017/07/26</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Write a Kubernetes-ready service from zero step-by-step" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">GO 零基础 step-by-step 写一个运行在 kubernetes 的服务</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="GOLANG">GOLANG</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-04-09 10:39:27'>2017-12-28 00:00</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:4.5k</span>
        
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-text">第一步 最简单的服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E6%B7%BB%E5%8A%A0%E6%97%A5%E5%BF%97"><span class="toc-text">第二步 添加日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5-%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="toc-text">第三步 添加路由器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5-%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95"><span class="toc-text">第四步 添加测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5-%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE"><span class="toc-text">第五步 添加配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AD%A5-%E6%B7%BB%E5%8A%A0Makefile"><span class="toc-text">第六步 添加Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E6%AD%A5-%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-text">第七步 添加版本控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E6%AD%A5-%E5%87%8F%E5%B0%91%E4%BE%9D%E8%B5%96"><span class="toc-text">第八步 减少依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E6%AD%A5-%E6%B7%BB%E5%8A%A0%E2%80%9C%E5%81%A5%E5%BA%B7%E2%80%9D%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%EF%BC%88health-checks%EF%BC%89"><span class="toc-text">第九步 添加“健康”检查功能（health checks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E6%AD%A5-%E6%B7%BB%E5%8A%A0%E5%B9%B3%E6%BB%91%E5%85%B3%E9%97%AD%E5%8A%9F%E8%83%BD"><span class="toc-text">第十步 添加平滑关闭功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E6%AD%A5-%E6%B7%BB%E5%8A%A0Dockerfile"><span class="toc-text">第十一步 添加Dockerfile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E6%AD%A5-%E6%B7%BB%E5%8A%A0vendor"><span class="toc-text">第十二步 添加vendor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E6%AD%A5-Kubernetes"><span class="toc-text">第十三步 Kubernetes</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果你用Go写过程序，就会发现用Go来写服务是很简单的事。比如说，只要几行代码就可以跑起来一个HTTP服务。但是如果想让服务在生产环境能运行起来，我们需要额外加一些东西。本文讨论服务如何能够在kubernets上运行起来。</p>
<p>文中所有的例子可以在<a href="https://github.com/rumyantseva/advent-2017/tree/all-steps">这里（按标签分类）</a>，或者<a href="https://github.com/rumyantseva/advent-2017/commits/master">这里（按commit分类）</a>找到。</p>
<h2 id="第一步-最简单的服务"><a href="#第一步-最简单的服务" class="headerlink" title="第一步 最简单的服务"></a>第一步 最简单的服务</h2><p>从一个最简单的应用开始：<br><code>main.go</code></p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func main() &#123;
    http.HandleFunc(&quot;/home&quot;, func(w http.ResponseWriter, _ *http.Request) &#123;
        fmt.Fprint(w, &quot;Hello! Your request was processed.&quot;)
    &#125;,
    )
    http.ListenAndServe(&quot;:8000&quot;, nil)
&#125;
</code></pre>
<p>执行<code>go run main.go</code>即可运行程序。用curl命令<code>curl -i http://127.0.0.1:8000/home</code>可以看到程序返回值。不过目前在终端并没有多少<strong>状态信息</strong>。</p>
<h2 id="第二步-添加日志"><a href="#第二步-添加日志" class="headerlink" title="第二步 添加日志"></a>第二步 添加日志</h2><p>添加一个logger便于查看执行到哪一行、记录错误信息以及其他重要状态。本例中简便起见，会使用Go标准库中的log，线上生产环境请使用更强大的日志系统，例如：<a href="https://github.com/golang/glog">glog</a>或者<a href="https://github.com/sirupsen/logrus">logrus</a>。</p>
<p>代码中有三个地方需要添加日志：服务开始时候、服务准备好可以接受请求时以及当<code>http.ListenAndServe</code>返回错误时。具体代码如下：</p>
<pre><code class="go">func main() &#123;
    log.Print(&quot;Starting the service...&quot;)

    http.HandleFunc(&quot;/home&quot;, func(w http.ResponseWriter, _ *http.Request) &#123;
        fmt.Fprint(w, &quot;Hello! Your request was processed.&quot;)
    &#125;,
    )

    log.Print(&quot;The service is ready to listen and serve.&quot;)
    log.Fatal(http.ListenAndServe(&quot;:8000&quot;, nil))
&#125;
</code></pre>
<p>一步步趋向完美。</p>
<h2 id="第三步-添加路由器"><a href="#第三步-添加路由器" class="headerlink" title="第三步 添加路由器"></a>第三步 添加路由器</h2><p>为了让应用更加可用，需要添加一个路由器（router），路由器能够以一种简单的方式处理各种不同的URI和HTTP方法，以及匹配一些其他的规则。Go标准库中没有包含路由器（router），本文使用<a href="https://github.com/gorilla/mux">gorilla&#x2F;mux</a>库，该库提供的路由器能够很好地和标准库<code>net\http</code>兼容。</p>
<p>服务中如果包含了一定数量的不同路由规则，那么最好是把路由相关的代码单独封装到几个独立的function或者是一个package中。本文中，会把规则定义和初始化路由器的代码放到<code>handlers</code>package中（<a href="https://github.com/rumyantseva/advent-2017/commit/1a61e7952e227e33eaab81404d7bff9278244080">这里</a>可以看到完整的改动）。</p>
<p>我们添加一个<code>Router</code>方法，该方法返回一个配置好的路由器变量，其中<code>home</code>方法处理<code>/home</code>路径的请求。个人建议处理方法和路由分开写：</p>
<p><code>handlers/handlers.go</code></p>
<pre><code class="go">package handlers

import (
    &quot;github.com/gorilla/mux&quot;
)

// Router register necessary routes and returns an instance of a router.
func Router() *mux.Router &#123;
    r := mux.NewRouter()
    r.HandleFunc(&quot;/home&quot;, home).Methods(&quot;GET&quot;)
    return r
&#125;
</code></pre>
<p><code>handlers/home.go</code></p>
<pre><code class="go">package handlers

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

// home is a simple HTTP handler function which writes a response.
func home(w http.ResponseWriter, _ *http.Request) &#123;
    fmt.Fprint(w, &quot;Hello! Your request was processed.&quot;)
&#125;
</code></pre>
<p>然后<code>main.go</code>中做点小改动：</p>
<pre><code class="go">package main

import (
    &quot;log&quot;
    &quot;net/http&quot;

    &quot;github.com/rumyantseva/advent-2017/handlers&quot;
)

// How to try it: go run main.go
func main() &#123;
    log.Print(&quot;Starting the service...&quot;)
    router := handlers.Router()
    log.Print(&quot;The service is ready to listen and serve.&quot;)
    log.Fatal(http.ListenAndServe(&quot;:8000&quot;, router))
&#125;
</code></pre>
<h2 id="第四步-添加测试"><a href="#第四步-添加测试" class="headerlink" title="第四步 添加测试"></a>第四步 添加测试</h2><p>这一步要开始加点测试了。我们用到了<code>httptest</code>包。<code>Router</code>方法的测试代码如下：</p>
<p><code>handlers/handlers_test.go</code>：</p>
<pre><code class="go">package handlers

import (
    &quot;net/http&quot;
    &quot;net/http/httptest&quot;
    &quot;testing&quot;
)

func TestRouter(t *testing.T) &#123;
    r := Router()
    ts := httptest.NewServer(r)
    defer ts.Close()

    res, err := http.Get(ts.URL + &quot;/home&quot;)
    if err != nil &#123;
        t.Fatal(err)
    &#125;
    if res.StatusCode != http.StatusOK &#123;
        t.Errorf(&quot;Status code for /home is wrong. Have: %d, want: %d.&quot;, res.StatusCode, http.StatusOK)
    &#125;

    res, err = http.Post(ts.URL+&quot;/home&quot;, &quot;text/plain&quot;, nil)
    if err != nil &#123;
        t.Fatal(err)
    &#125;
    if res.StatusCode != http.StatusMethodNotAllowed &#123;
        t.Errorf(&quot;Status code for /home is wrong. Have: %d, want: %d.&quot;, res.StatusCode, http.StatusMethodNotAllowed)
    &#125;

    res, err = http.Get(ts.URL + &quot;/not-exists&quot;)
    if err != nil &#123;
        t.Fatal(err)
    &#125;
    if res.StatusCode != http.StatusNotFound &#123;
        t.Errorf(&quot;Status code for /home is wrong. Have: %d, want: %d.&quot;, res.StatusCode, http.StatusNotFound)
    &#125;
&#125;
</code></pre>
<p>检查了<code>GET</code>请求<code>/home</code>路径是否返回<code>200</code>，而<code>POST</code>请求该路径应该要返回<code>405</code>。请求不存在的路由期望返回<code>404</code>。实际上，这样子测有点太冗余了，<code>gorilla/mux</code>中已经包含类似的测试，所以测试代码可以简化下。</p>
<p>对于<code>home</code>来说，检查其返回得code和body值即可。</p>
<p><code>handlers/home_test.go</code></p>
<pre><code class="go">package handlers

import (
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;net/http/httptest&quot;
    &quot;testing&quot;
)

func TestHome(t *testing.T) &#123;
    w := httptest.NewRecorder()
    home(w, nil)

    resp := w.Result()
    if have, want := resp.StatusCode, http.StatusOK; have != want &#123;
        t.Errorf(&quot;Status code is wrong. Have: %d, want: %d.&quot;, have, want)
    &#125;

    greeting, err := ioutil.ReadAll(resp.Body)
    resp.Body.Close()
    if err != nil &#123;
        t.Fatal(err)
    &#125;
    if have, want := string(greeting), &quot;Hello! Your request was processed.&quot;; have != want &#123;
        t.Errorf(&quot;The greeting is wrong. Have: %s, want: %s.&quot;, have, want)
    &#125;
&#125;
</code></pre>
<p>运行<code>go test</code>开始测试。</p>
<pre><code>$ go test -v ./...
?       github.com/rumyantseva/advent-2017      [no test files]
=== RUN   TestRouter
--- PASS: TestRouter (0.00s)
=== RUN   TestHome
--- PASS: TestHome (0.00s)
PASS
ok      github.com/rumyantseva/advent-2017/handlers     0.018s
</code></pre>
<h2 id="第五步-添加配置"><a href="#第五步-添加配置" class="headerlink" title="第五步 添加配置"></a>第五步 添加配置</h2><p>服务需要能够可配置。前面代码，写死监听<code>8000</code>端口，后面需要改成可配置。<a target="_blank" rel="noopener" href="https://12factor.net/">The Twelve-Factor App manifesto</a>，这篇文章详尽阐述了如何写好服务，文中提倡在环境变量中存放配置。后面代码展示如何利用环境变量：</p>
<p><code>main.go</code></p>
<pre><code class="go">package main

import (
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;os&quot;

    &quot;github.com/rumyantseva/advent-2017/handlers&quot;
)

// How to try it: PORT=8000 go run main.go
func main() &#123;
    log.Print(&quot;Starting the service...&quot;)

    port := os.Getenv(&quot;PORT&quot;)
    if port == &quot;&quot; &#123;
        log.Fatal(&quot;Port is not set.&quot;)
    &#125;

    r := handlers.Router()
    log.Print(&quot;The service is ready to listen and serve.&quot;)
    log.Fatal(http.ListenAndServe(&quot;:&quot;+port, r))
&#125;
</code></pre>
<p>上例中，若没有设置port值，会返回错误。如果配置错误的话，没有必要继续执行后面代码。</p>
<h2 id="第六步-添加Makefile"><a href="#第六步-添加Makefile" class="headerlink" title="第六步 添加Makefile"></a>第六步 添加Makefile</h2><p>前几天看过一篇关于<code>make</code>的<a target="_blank" rel="noopener" href="https://blog.gopheracademy.com/advent-2017/make/">文章</a>，如果想要把一些重复性高的常用的东西做成自动化，推荐看看该文。让我们看下怎么用上<code>make</code>，目前有两个操作：运行测试、编译并运行服务，把这两个操作加到Makefile文件中。这里我们用到<code>go build</code>命令，后面会运行编译好的二进制文件，这种方式更符合”适配生产环境”的目标，所以就不会用到<code>go run</code>命令了。</p>
<p><code>Makefile</code></p>
<pre><code>APP?=advent
PORT?=8000

clean:
    rm -f $&#123;APP&#125;

build: clean
    go build -o $&#123;APP&#125;

run: build
    PORT=$&#123;PORT&#125; ./$&#123;APP&#125;

test:
    go test -v -race ./...
</code></pre>
<p>上例中把二进制文件名单独放到变量<code>APP</code>中，减少重复定义名称次数。</p>
<p>运行程序前，先删除旧的二进制文件（存在的话），然后编译代码、设置正确的环境变量并运行新生成的二进制文件，这些操作可以通过执行<code>make run</code>命令完成。</p>
<h2 id="第七步-添加版本控制"><a href="#第七步-添加版本控制" class="headerlink" title="第七步 添加版本控制"></a>第七步 添加版本控制</h2><p>这一步要添加到服务中的是版本控制功能。某些场景下，知道生产环境中所使用的具体是哪个构建和commit以及什么时间构建的是非常有用的。</p>
<p>添加一个新的包<code>version</code>来保存这些信息。</p>
<p><code>version/version.go</code></p>
<pre><code class="go">package version

var (
    // BuildTime is a time label of the moment when the binary was built
    BuildTime = &quot;unset&quot;
    // Commit is a last commit hash at the moment when the binary was built
    Commit = &quot;unset&quot;
    // Release is a semantic version of current build
    Release = &quot;unset&quot;
)
</code></pre>
<p>程序启动时，会将这些变量打到日志中。</p>
<p><code>main.go</code></p>
<pre><code class="go">...
func main() &#123;
    log.Printf(
        &quot;Starting the service...\ncommit: %s, build time: %s, release: %s&quot;,
        version.Commit, version.BuildTime, version.Release,
    )
...
&#125;
</code></pre>
<p>也可以把这些信息添加到<code>home</code>handler中（别忘了更新对应的测试方法）：</p>
<p><code>handlers/home.go</code></p>
<pre><code class="go">package handlers

import (
    &quot;encoding/json&quot;
    &quot;log&quot;
    &quot;net/http&quot;

    &quot;github.com/rumyantseva/advent-2017/version&quot;
)

// home is a simple HTTP handler function which writes a response.
func home(w http.ResponseWriter, _ *http.Request) &#123;
    info := struct &#123;
        BuildTime string `json:&quot;buildTime&quot;`
        Commit    string `json:&quot;commit&quot;`
        Release   string `json:&quot;release&quot;`
    &#125;&#123;
        version.BuildTime, version.Commit, version.Release,
    &#125;

    body, err := json.Marshal(info)
    if err != nil &#123;
        log.Printf(&quot;Could not encode info data: %v&quot;, err)
        http.Error(w, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)
        return
    &#125;
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.Write(body)
&#125;
</code></pre>
<p>通过Go链接器在编译时设置<code>BuildTime</code>，<code>Commit</code>以及<code>Release</code>变量。</p>
<p>先在Makefile中添加新变量：</p>
<p><code>Makefile</code></p>
<pre><code>RELEASE?=0.0.1
COMMIT?=$(shell git rev-parse --short HEAD)
BUILD_TIME?=$(shell date -u &#39;+%Y-%m-%d_%H:%M:%S&#39;)
</code></pre>
<p><code>COMMIT</code>和<code>BUILD_TIME</code>（译者注：原文这里写<code>RELEASE</code>，可能有误）通过已有的命令获取，<code>RELEASE</code>的赋值按照<a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/06/24/gophers-please-tag-your-releases">语义化版本控制规范</a>来。</p>
<p>好，现在重写Makefile的<code>build</code>目标，用上上面定义的变量：</p>
<p><code>Makefile</code></p>
<pre><code>build: clean
    go build \
        -ldflags &quot;-s -w -X $&#123;PROJECT&#125;/version.Release=$&#123;RELEASE&#125; \
        -X $&#123;PROJECT&#125;/version.Commit=$&#123;COMMIT&#125; -X $&#123;PROJECT&#125;/version.BuildTime=$&#123;BUILD_TIME&#125;&quot; \
        -o $&#123;APP&#125;
</code></pre>
<p>将<code>PROJECT</code>变量添加到<code>Makefile</code>开头地方（减少多处定义）。</p>
<p><code>Makefile</code></p>
<pre><code>PROJECT?=github.com/rumyantseva/advent-2017
</code></pre>
<p>本步所有代码变更记录可以在<a href="https://github.com/rumyantseva/advent-2017/commit/eaa4ff224b32fb343f5eac2a1204cc3806a22efd">这里</a>找到。可以多动手尝试运行下<code>make run</code>命令，看看具体是怎么工作的。</p>
<h2 id="第八步-减少依赖"><a href="#第八步-减少依赖" class="headerlink" title="第八步 减少依赖"></a>第八步 减少依赖</h2><p>之前代码有个不尽如人意的点：<code>handler</code>包依赖<code>version</code>包。做个简单的改动，让<code>home</code>处理器变成可配置的，减少依赖：</p>
<p><code>handlers/home.go</code></p>
<pre><code class="go">// home returns a simple HTTP handler function which writes a response.
func home(buildTime, commit, release string) http.HandlerFunc &#123;
    return func(w http.ResponseWriter, _ *http.Request) &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>同样，别忘了<a href="https://github.com/rumyantseva/advent-2017/commit/e73b996f8522b736c150e53db059cf041c7c3e64">改</a>测试代码。</p>
<h2 id="第九步-添加“健康”检查功能（health-checks）"><a href="#第九步-添加“健康”检查功能（health-checks）" class="headerlink" title="第九步 添加“健康”检查功能（health checks）"></a>第九步 添加“健康”检查功能（health checks）</h2><p>某些情况下，想在kubernetes上跑服务，需要添加“健康”检查功能: <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">liveness和readiness检测</a>。liveness检测目的是测试程序是否还在跑。如果liveness检测失败，服务会被重启。readiness检测目的是测试程序是否准备好可以接受请求。如果readiness检测失败，该容器会从服务负载均衡器中移除。</p>
<p>实现liveness检测的方式，可以简单写一个handler返回<code>200</code>:</p>
<p><code>handlers/healthz.go</code></p>
<pre><code class="go">// healthz is a liveness probe.
func healthz(w http.ResponseWriter, _ *http.Request) &#123;
    w.WriteHeader(http.StatusOK)
&#125;
</code></pre>
<p>readiness检测实现方式类似，不同的就是可能要等待某事件完成（例如：数据库已起来）：</p>
<p><code>handlers/readyz.go</code></p>
<pre><code class="go">// readyz is a readiness probe.
func readyz(isReady *atomic.Value) http.HandlerFunc &#123;
    return func(w http.ResponseWriter, _ *http.Request) &#123;
        if isReady == nil || !isReady.Load().(bool) &#123;
            http.Error(w, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)
            return
        &#125;
        w.WriteHeader(http.StatusOK)
    &#125;
&#125;
</code></pre>
<p>当<code>isReady</code>有值并且为<code>true</code>，返回<code>200</code>。</p>
<p>例子如下：</p>
<p><code>handlers.go</code></p>
<pre><code class="go">func Router(buildTime, commit, release string) *mux.Router &#123;
    isReady := &amp;atomic.Value&#123;&#125;
    isReady.Store(false)
    go func() &#123;
        log.Printf(&quot;Readyz probe is negative by default...&quot;)
        time.Sleep(10 * time.Second)
        isReady.Store(true)
        log.Printf(&quot;Readyz probe is positive.&quot;)
    &#125;()

    r := mux.NewRouter()
    r.HandleFunc(&quot;/home&quot;, home(buildTime, commit, release)).Methods(&quot;GET&quot;)
    r.HandleFunc(&quot;/healthz&quot;, healthz)
    r.HandleFunc(&quot;/readyz&quot;, readyz(isReady))
    return r
&#125;
</code></pre>
<p>设置等待10s后服务可以处理请求。当然，实际业务代码不会有空等10s的情况，这里是模拟cache warming（如果有用cache）或者其他情况。</p>
<p>代码改动<a href="https://github.com/rumyantseva/advent-2017/commit/e73b996f8522b736c150e53db059cf041c7c3e64">GitHub</a>上可以找到。</p>
<p>注意：如果流量过大，服务节点的响应会不稳定。例如，liveness检测会因为超时失败。这就是为什么一些工程师不用liveness检测的原因。个人认为，当发现请求越来越多时候，最好是去扩容；例如可以参考<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">scale pods with HPA</a>。</p>
<h2 id="第十步-添加平滑关闭功能"><a href="#第十步-添加平滑关闭功能" class="headerlink" title="第十步 添加平滑关闭功能"></a>第十步 添加平滑关闭功能</h2><p>关闭服务时，最好是不要立即中断连接、请求或者其他一些操作，而应该平滑关闭。Go从1.8版本支持平滑关闭<code>http.Server</code>。下面看看怎么用：</p>
<p><code>main.go</code></p>
<pre><code class="go">func main() &#123;
    ...
    r := handlers.Router(version.BuildTime, version.Commit, version.Release)

    interrupt := make(chan os.Signal, 1)
    signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)

    srv := &amp;http.Server&#123;
        Addr:    &quot;:&quot; + port,
        Handler: r,
    &#125;
    go func() &#123;
        log.Fatal(srv.ListenAndServe())
    &#125;()
    log.Print(&quot;The service is ready to listen and serve.&quot;)

    killSignal := &lt;-interrupt
    switch killSignal &#123;
    case os.Interrupt:
        log.Print(&quot;Got SIGINT...&quot;)
    case syscall.SIGTERM:
        log.Print(&quot;Got SIGTERM...&quot;)
    &#125;

    log.Print(&quot;The service is shutting down...&quot;)
    srv.Shutdown(context.Background())
    log.Print(&quot;Done&quot;)
&#125;
</code></pre>
<p>收到<code>SIGINT</code>或<code>SIGTERM</code>任意一个系统信号，服务平滑关闭。</p>
<p>注意：这段代码的旧版本，尝试去捕获<code>SIGKILL</code>信号。之前在不同的库中有看到过这种用法，我（作者）确认这样是行的通的。但是后来Sandor Szücs<a target="_blank" rel="noopener" href="https://twitter.com/sszuecs/status/941582509565005824">指出</a>，不可能获取到<code>SIGKILL</code>信号。发出<code>SIGKILL</code>信号后，程序会直接结束。</p>
<h2 id="第十一步-添加Dockerfile"><a href="#第十一步-添加Dockerfile" class="headerlink" title="第十一步 添加Dockerfile"></a>第十一步 添加Dockerfile</h2><p>程序基本上可以在Kubernetes上跑了。这一步进行docker化。</p>
<p>先添加一个简单的<code>Dockerfile</code>，如下：</p>
<p><code>Dockerfile</code>：</p>
<pre><code>FROM scratch

ENV PORT 8000
EXPOSE $PORT

COPY advent /
CMD [&quot;/advent&quot;]
</code></pre>
<p>创建了一个最小的容器，复制二进制到容器内然后运行（别忘了<code>PORT</code>配置变量）。</p>
<p>扩展<code>Makefile</code>，使其能够构建镜像以及运行容器。同时添加<code>GOOS</code>和<code>GOARCH</code>变量，在<code>build</code>goal中交叉编译要用到。</p>
<p><code>Makefile</code></p>
<pre><code>...

GOOS?=linux
GOARCH?=amd64

...

build: clean
    CGO_ENABLED=0 GOOS=$&#123;GOOS&#125; GOARCH=$&#123;GOARCH&#125; go build \
        -ldflags &quot;-s -w -X $&#123;PROJECT&#125;/version.Release=$&#123;RELEASE&#125; \
        -X $&#123;PROJECT&#125;/version.Commit=$&#123;COMMIT&#125; -X $&#123;PROJECT&#125;/version.BuildTime=$&#123;BUILD_TIME&#125;&quot; \
        -o $&#123;APP&#125;

container: build
    docker build -t $(APP):$(RELEASE) .

run: container
    docker stop $(APP):$(RELEASE) || true &amp;&amp; docker rm $(APP):$(RELEASE) || true
    docker run --name $&#123;APP&#125; -p $&#123;PORT&#125;:$&#123;PORT&#125; --rm \
        -e &quot;PORT=$&#123;PORT&#125;&quot; \
        $(APP):$(RELEASE)

...
</code></pre>
<p>添加了<code>container</code>和<code>run</code>goal，前者构建镜像，后者从容器启动程序。所有改动<a href="https://github.com/rumyantseva/advent-2017/commit/909fef6d585c85c5e16b5b0e4fdbdf080893b679">这里</a>可以找到。</p>
<p>请尝试运行<code>make run</code>命令，检查所有过程是否正确。</p>
<h2 id="第十二步-添加vendor"><a href="#第十二步-添加vendor" class="headerlink" title="第十二步 添加vendor"></a>第十二步 添加vendor</h2><p>项目中依赖了外部代码（<a href="github.com/gorilla/mux">github.com&#x2F;gorilla&#x2F;mux</a>），所以肯定要<a href="https://github.com/rumyantseva/advent-2017/commit/7ffa56a78400367e5d633521dee816b767d7d05d">加入依赖管理</a>。如果引入<code>dep</code>的话，就只要执行<code>dep init</code>：</p>
<pre><code>$ dep init
  Using ^1.6.0 as constraint for direct dep github.com/gorilla/mux
  Locking in v1.6.0 (7f08801) for direct dep github.com/gorilla/mux
  Locking in v1.1 (1ea2538) for transitive dep github.com/gorilla/context
</code></pre>
<p>会创建<code>Gopkg.toml</code>和<code>Gopkg.lock</code>文件以及<code>vendor</code>目录。个人观点，推荐push<code>vendor</code>到git，重要的项目尤其应该push上去。</p>
<h2 id="第十三步-Kubernetes"><a href="#第十三步-Kubernetes" class="headerlink" title="第十三步 Kubernetes"></a>第十三步 Kubernetes</h2><p><a href="https://github.com/rumyantseva/advent-2017/commit/27b256191dc8d4530c895091c49b8a9293932e0f">最后一步</a>，将程序部署到Kubernets上运行。本地环境最简单方式就是安装、配置<a href="https://github.com/kubernetes/minikube">minikube</a>。</p>
<p>Kubernetes从Docker registry拉取镜像。本文中，使用公共Docker registry–<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。<code>Makefile</code>中还要添加一个变量和命令：</p>
<pre><code>CONTAINER_IMAGE?=docker.io/webdeva/$&#123;APP&#125;

...

container: build
    docker build -t $(CONTAINER_IMAGE):$(RELEASE) .

...

push: container
    docker push $(CONTAINER_IMAGE):$(RELEASE)
</code></pre>
<p><code>CONTAINER_IMAGE</code>变量定义了push、pull镜像的Docker registry repo，路径中包含了用户名（webdeva）。如果没有<a href="hub.docker.com">hub.docker.com</a>账户，请创建账户并通过<code>docker login</code>登录。这样就可以push镜像了。</p>
<p>运行<code>make push</code>：</p>
<pre><code>$ make push
...
docker build -t docker.io/webdeva/advent:0.0.1 .
Sending build context to Docker daemon   5.25MB
...
Successfully built d3cc8f4121fe
Successfully tagged webdeva/advent:0.0.1
docker push docker.io/webdeva/advent:0.0.1
The push refers to a repository [docker.io/webdeva/advent]
ee1f0f98199f: Pushed
0.0.1: digest: sha256:fb3a25b19946787e291f32f45931ffd95a933100c7e55ab975e523a02810b04c size: 528
</code></pre>
<p>成功了~！然后可以在<a target="_blank" rel="noopener" href="https://hub.docker.com/r/webdeva/advent/tags/">这里找到镜像</a>。</p>
<p>接下来，定义必要的Kubernetes配置（manifest）。通常，一个服务至少需要设置deployment、service和ingress配置。默认情况，manifest都是静态的，即其中不能使用任何变量。不过可以通过<a href="https://github.com/kubernetes/helm">helm工具</a>创建更灵活的配置。</p>
<p>本文中，没有用<code>helm</code>，定义了两个变量：<code>ServiceName</code>和<code>Release</code>，灵活性更高些。后面通过<code>sed</code>命令替换“变量”为实际值。</p>
<p>先看下deployment配置：<br><code>deployment.yaml</code></p>
<pre><code>apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: &#123;&#123; .ServiceName &#125;&#125;
  labels:
    app: &#123;&#123; .ServiceName &#125;&#125;
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 50%
      maxSurge: 1
  template:
    metadata:
      labels:
        app: &#123;&#123; .ServiceName &#125;&#125;
    spec:
      containers:
      - name: &#123;&#123; .ServiceName &#125;&#125;
        image: docker.io/webdeva/&#123;&#123; .ServiceName &#125;&#125;:&#123;&#123; .Release &#125;&#125;
        imagePullPolicy: Always
        ports:
        - containerPort: 8000
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8000
        readinessProbe:
          httpGet:
            path: /readyz
            port: 8000
        resources:
          limits:
            cpu: 10m
            memory: 30Mi
          requests:
            cpu: 10m
            memory: 30Mi
      terminationGracePeriodSeconds: 30
</code></pre>
<p>Kubernetes的配置要讲清楚可以单独写一篇文章了，这里用到了容器镜像和liveness、readiness检测功能，去哪里找镜像，以及检测模块的路径前文都有阐述。</p>
<p>一个经典的服务更简单：</p>
<p><code>service.yaml</code></p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: &#123;&#123; .ServiceName &#125;&#125;
  labels:
    app: &#123;&#123; .ServiceName &#125;&#125;
spec:
  ports:
  - port: 80
    targetPort: 8000
    protocol: TCP
    name: http
  selector:
    app: &#123;&#123; .ServiceName &#125;&#125;
</code></pre>
<p>最后，定义下ingress。定义从外部访问访问Kubernetes中服务的规则。这里假定把服务“attach”到<code>advent.test</code>域上（实际不是）。</p>
<p><code>ingress.yaml</code></p>
<pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    ingress.kubernetes.io/rewrite-target: /
  labels:
    app: &#123;&#123; .ServiceName &#125;&#125;
  name: &#123;&#123; .ServiceName &#125;&#125;
spec:
  backend:
    serviceName: &#123;&#123; .ServiceName &#125;&#125;
    servicePort: 80
  rules:
  - host: advent.test
    http:
      paths:
      - path: /
        backend:
          serviceName: &#123;&#123; .ServiceName &#125;&#125;
          servicePort: 80
</code></pre>
<p>验证配置是否正确，需要安装、运行<code>minikube</code>，官方文档在<a href="https://github.com/kubernetes/minikube#installation">这里</a>，还需要安装<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">kubectl</a>工具，用来提供配置和检验服务。</p>
<p>启动<code>minikube</code>，<code>ingress</code>，<code>kubectl</code>命令如下：</p>
<pre><code>minikube start
minikube addons enable ingress
kubectl config use-context minikube
</code></pre>
<p>接下来，给<code>Makefile</code>添加新goal：安装服务到<code>minikube</code>上。</p>
<p><code>Makefile</code></p>
<pre><code>minikube: push
    for t in $(shell find ./kubernetes/advent -type f -name &quot;*.yaml&quot;); do \
        cat $$t | \
            gsed -E &quot;s/\&#123;\&#123;(\s*)\.Release(\s*)\&#125;\&#125;/$(RELEASE)/g&quot; | \
            gsed -E &quot;s/\&#123;\&#123;(\s*)\.ServiceName(\s*)\&#125;\&#125;/$(APP)/g&quot;; \
        echo ---; \
    done &gt; tmp.yaml
    kubectl apply -f tmp.yaml
</code></pre>
<p>上面命令“编译”所有<code>*.yaml</code>配置到一个文件。用实际值替换<code>Release</code>和<code>ServiceName</code>变量（注意，这里用了<code>gsed</code>而非标准<code>sed</code>）,最后运行<code>kubectl apply</code>命令安装应用到Kubernetes上。</p>
<p>验证配置是否正确：</p>
<pre><code>$ kubectl get deployment
NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
advent    3         3         3            3           1d

$ kubectl get service
NAME         CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
advent       10.109.133.147   &lt;none&gt;        80/TCP    1d

$ kubectl get ingress
NAME      HOSTS         ADDRESS        PORTS     AGE
advent    advent.test   192.168.64.2   80        1d
</code></pre>
<p>先在<code>/etc/host</code>文件添加模拟域名<code>advent.test</code>，然后可以发请求测试服务了。</p>
<pre><code>echo &quot;$(minikube ip) advent.test&quot; | sudo tee -a /etc/hosts
</code></pre>
<pre><code>curl -i http://advent.test/home
HTTP/1.1 200 OK
Server: nginx/1.13.6
Date: Sun, 10 Dec 2017 20:40:37 GMT
Content-Type: application/json
Content-Length: 72
Connection: keep-alive
Vary: Accept-Encoding

&#123;&quot;buildTime&quot;:&quot;2017-12-10_11:29:59&quot;,&quot;commit&quot;:&quot;020a181&quot;,&quot;release&quot;:&quot;0.0.5&quot;&#125;%
</code></pre>
<p>成功~！</p>
<hr>
<p>via: <a target="_blank" rel="noopener" href="https://blog.gopheracademy.com/advent-2017/kubernetes-ready-service/">https://blog.gopheracademy.com/advent-2017/kubernetes-ready-service/</a></p>
<p>作者：<a href="https://github.com/jeffallen">Elena Grahovac</a><br>译者：<a href="https://github.com/dongfengkuayue">dongfengkuayue</a><br>校对：<a href="https://github.com/%E6%A0%A1%E5%AF%B9%E8%80%85ID">校对者ID</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://studygolang.com/">Go 中文网</a> 荣誉推出</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论 </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '3eb9f1494fdc12cf083e',
            clientSecret: 'e867264757fe5cb3cf1c530cc991246cc47a929e',
            repo: 'dongfengkuayue.github.io',
            owner: 'dongfengkuayue',
            admin: ['dongfengkuayue'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2022 zich
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
