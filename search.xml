<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GO 零基础 step-by-step 写一个运行在 kubernetes 的服务</title>
      <link href="/2017/12/28/Write%20a%20Kubernetes-ready%20service%20from%20zero%20step-by-step/"/>
      <url>/2017/12/28/Write%20a%20Kubernetes-ready%20service%20from%20zero%20step-by-step/</url>
      
        <content type="html"><![CDATA[<p>如果你用Go写过程序，就会发现用Go来写服务是很简单的事。比如说，只要几行代码就可以跑起来一个HTTP服务。但是如果想让服务在生产环境能运行起来，我们需要额外加一些东西。本文讨论服务如何能够在kubernets上运行起来。</p><p>文中所有的例子可以在<a href="https://github.com/rumyantseva/advent-2017/tree/all-steps">这里（按标签分类）</a>，或者<a href="https://github.com/rumyantseva/advent-2017/commits/master">这里（按commit分类）</a>找到。</p><h2 id="第一步-最简单的服务"><a href="#第一步-最简单的服务" class="headerlink" title="第一步 最简单的服务"></a>第一步 最简单的服务</h2><p>从一个最简单的应用开始：<br><code>main.go</code></p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;net/http&quot;)func main() &#123;    http.HandleFunc(&quot;/home&quot;, func(w http.ResponseWriter, _ *http.Request) &#123;        fmt.Fprint(w, &quot;Hello! Your request was processed.&quot;)    &#125;,    )    http.ListenAndServe(&quot;:8000&quot;, nil)&#125;</code></pre><p>执行<code>go run main.go</code>即可运行程序。用curl命令<code>curl -i http://127.0.0.1:8000/home</code>可以看到程序返回值。不过目前在终端并没有多少<strong>状态信息</strong>。</p><h2 id="第二步-添加日志"><a href="#第二步-添加日志" class="headerlink" title="第二步 添加日志"></a>第二步 添加日志</h2><p>添加一个logger便于查看执行到哪一行、记录错误信息以及其他重要状态。本例中简便起见，会使用Go标准库中的log，线上生产环境请使用更强大的日志系统，例如：<a href="https://github.com/golang/glog">glog</a>或者<a href="https://github.com/sirupsen/logrus">logrus</a>。</p><p>代码中有三个地方需要添加日志：服务开始时候、服务准备好可以接受请求时以及当<code>http.ListenAndServe</code>返回错误时。具体代码如下：</p><pre><code class="go">func main() &#123;    log.Print(&quot;Starting the service...&quot;)    http.HandleFunc(&quot;/home&quot;, func(w http.ResponseWriter, _ *http.Request) &#123;        fmt.Fprint(w, &quot;Hello! Your request was processed.&quot;)    &#125;,    )    log.Print(&quot;The service is ready to listen and serve.&quot;)    log.Fatal(http.ListenAndServe(&quot;:8000&quot;, nil))&#125;</code></pre><p>一步步趋向完美。</p><h2 id="第三步-添加路由器"><a href="#第三步-添加路由器" class="headerlink" title="第三步 添加路由器"></a>第三步 添加路由器</h2><p>为了让应用更加可用，需要添加一个路由器（router），路由器能够以一种简单的方式处理各种不同的URI和HTTP方法，以及匹配一些其他的规则。Go标准库中没有包含路由器（router），本文使用<a href="https://github.com/gorilla/mux">gorilla&#x2F;mux</a>库，该库提供的路由器能够很好地和标准库<code>net\http</code>兼容。</p><p>服务中如果包含了一定数量的不同路由规则，那么最好是把路由相关的代码单独封装到几个独立的function或者是一个package中。本文中，会把规则定义和初始化路由器的代码放到<code>handlers</code>package中（<a href="https://github.com/rumyantseva/advent-2017/commit/1a61e7952e227e33eaab81404d7bff9278244080">这里</a>可以看到完整的改动）。</p><p>我们添加一个<code>Router</code>方法，该方法返回一个配置好的路由器变量，其中<code>home</code>方法处理<code>/home</code>路径的请求。个人建议处理方法和路由分开写：</p><p><code>handlers/handlers.go</code></p><pre><code class="go">package handlersimport (    &quot;github.com/gorilla/mux&quot;)// Router register necessary routes and returns an instance of a router.func Router() *mux.Router &#123;    r := mux.NewRouter()    r.HandleFunc(&quot;/home&quot;, home).Methods(&quot;GET&quot;)    return r&#125;</code></pre><p><code>handlers/home.go</code></p><pre><code class="go">package handlersimport (    &quot;fmt&quot;    &quot;net/http&quot;)// home is a simple HTTP handler function which writes a response.func home(w http.ResponseWriter, _ *http.Request) &#123;    fmt.Fprint(w, &quot;Hello! Your request was processed.&quot;)&#125;</code></pre><p>然后<code>main.go</code>中做点小改动：</p><pre><code class="go">package mainimport (    &quot;log&quot;    &quot;net/http&quot;    &quot;github.com/rumyantseva/advent-2017/handlers&quot;)// How to try it: go run main.gofunc main() &#123;    log.Print(&quot;Starting the service...&quot;)    router := handlers.Router()    log.Print(&quot;The service is ready to listen and serve.&quot;)    log.Fatal(http.ListenAndServe(&quot;:8000&quot;, router))&#125;</code></pre><h2 id="第四步-添加测试"><a href="#第四步-添加测试" class="headerlink" title="第四步 添加测试"></a>第四步 添加测试</h2><p>这一步要开始加点测试了。我们用到了<code>httptest</code>包。<code>Router</code>方法的测试代码如下：</p><p><code>handlers/handlers_test.go</code>：</p><pre><code class="go">package handlersimport (    &quot;net/http&quot;    &quot;net/http/httptest&quot;    &quot;testing&quot;)func TestRouter(t *testing.T) &#123;    r := Router()    ts := httptest.NewServer(r)    defer ts.Close()    res, err := http.Get(ts.URL + &quot;/home&quot;)    if err != nil &#123;        t.Fatal(err)    &#125;    if res.StatusCode != http.StatusOK &#123;        t.Errorf(&quot;Status code for /home is wrong. Have: %d, want: %d.&quot;, res.StatusCode, http.StatusOK)    &#125;    res, err = http.Post(ts.URL+&quot;/home&quot;, &quot;text/plain&quot;, nil)    if err != nil &#123;        t.Fatal(err)    &#125;    if res.StatusCode != http.StatusMethodNotAllowed &#123;        t.Errorf(&quot;Status code for /home is wrong. Have: %d, want: %d.&quot;, res.StatusCode, http.StatusMethodNotAllowed)    &#125;    res, err = http.Get(ts.URL + &quot;/not-exists&quot;)    if err != nil &#123;        t.Fatal(err)    &#125;    if res.StatusCode != http.StatusNotFound &#123;        t.Errorf(&quot;Status code for /home is wrong. Have: %d, want: %d.&quot;, res.StatusCode, http.StatusNotFound)    &#125;&#125;</code></pre><p>检查了<code>GET</code>请求<code>/home</code>路径是否返回<code>200</code>，而<code>POST</code>请求该路径应该要返回<code>405</code>。请求不存在的路由期望返回<code>404</code>。实际上，这样子测有点太冗余了，<code>gorilla/mux</code>中已经包含类似的测试，所以测试代码可以简化下。</p><p>对于<code>home</code>来说，检查其返回得code和body值即可。</p><p><code>handlers/home_test.go</code></p><pre><code class="go">package handlersimport (    &quot;io/ioutil&quot;    &quot;net/http&quot;    &quot;net/http/httptest&quot;    &quot;testing&quot;)func TestHome(t *testing.T) &#123;    w := httptest.NewRecorder()    home(w, nil)    resp := w.Result()    if have, want := resp.StatusCode, http.StatusOK; have != want &#123;        t.Errorf(&quot;Status code is wrong. Have: %d, want: %d.&quot;, have, want)    &#125;    greeting, err := ioutil.ReadAll(resp.Body)    resp.Body.Close()    if err != nil &#123;        t.Fatal(err)    &#125;    if have, want := string(greeting), &quot;Hello! Your request was processed.&quot;; have != want &#123;        t.Errorf(&quot;The greeting is wrong. Have: %s, want: %s.&quot;, have, want)    &#125;&#125;</code></pre><p>运行<code>go test</code>开始测试。</p><pre><code>$ go test -v ./...?       github.com/rumyantseva/advent-2017      [no test files]=== RUN   TestRouter--- PASS: TestRouter (0.00s)=== RUN   TestHome--- PASS: TestHome (0.00s)PASSok      github.com/rumyantseva/advent-2017/handlers     0.018s</code></pre><h2 id="第五步-添加配置"><a href="#第五步-添加配置" class="headerlink" title="第五步 添加配置"></a>第五步 添加配置</h2><p>服务需要能够可配置。前面代码，写死监听<code>8000</code>端口，后面需要改成可配置。<a href="https://12factor.net/">The Twelve-Factor App manifesto</a>，这篇文章详尽阐述了如何写好服务，文中提倡在环境变量中存放配置。后面代码展示如何利用环境变量：</p><p><code>main.go</code></p><pre><code class="go">package mainimport (    &quot;log&quot;    &quot;net/http&quot;    &quot;os&quot;    &quot;github.com/rumyantseva/advent-2017/handlers&quot;)// How to try it: PORT=8000 go run main.gofunc main() &#123;    log.Print(&quot;Starting the service...&quot;)    port := os.Getenv(&quot;PORT&quot;)    if port == &quot;&quot; &#123;        log.Fatal(&quot;Port is not set.&quot;)    &#125;    r := handlers.Router()    log.Print(&quot;The service is ready to listen and serve.&quot;)    log.Fatal(http.ListenAndServe(&quot;:&quot;+port, r))&#125;</code></pre><p>上例中，若没有设置port值，会返回错误。如果配置错误的话，没有必要继续执行后面代码。</p><h2 id="第六步-添加Makefile"><a href="#第六步-添加Makefile" class="headerlink" title="第六步 添加Makefile"></a>第六步 添加Makefile</h2><p>前几天看过一篇关于<code>make</code>的<a href="https://blog.gopheracademy.com/advent-2017/make/">文章</a>，如果想要把一些重复性高的常用的东西做成自动化，推荐看看该文。让我们看下怎么用上<code>make</code>，目前有两个操作：运行测试、编译并运行服务，把这两个操作加到Makefile文件中。这里我们用到<code>go build</code>命令，后面会运行编译好的二进制文件，这种方式更符合”适配生产环境”的目标，所以就不会用到<code>go run</code>命令了。</p><p><code>Makefile</code></p><pre><code>APP?=adventPORT?=8000clean:    rm -f $&#123;APP&#125;build: clean    go build -o $&#123;APP&#125;run: build    PORT=$&#123;PORT&#125; ./$&#123;APP&#125;test:    go test -v -race ./...</code></pre><p>上例中把二进制文件名单独放到变量<code>APP</code>中，减少重复定义名称次数。</p><p>运行程序前，先删除旧的二进制文件（存在的话），然后编译代码、设置正确的环境变量并运行新生成的二进制文件，这些操作可以通过执行<code>make run</code>命令完成。</p><h2 id="第七步-添加版本控制"><a href="#第七步-添加版本控制" class="headerlink" title="第七步 添加版本控制"></a>第七步 添加版本控制</h2><p>这一步要添加到服务中的是版本控制功能。某些场景下，知道生产环境中所使用的具体是哪个构建和commit以及什么时间构建的是非常有用的。</p><p>添加一个新的包<code>version</code>来保存这些信息。</p><p><code>version/version.go</code></p><pre><code class="go">package versionvar (    // BuildTime is a time label of the moment when the binary was built    BuildTime = &quot;unset&quot;    // Commit is a last commit hash at the moment when the binary was built    Commit = &quot;unset&quot;    // Release is a semantic version of current build    Release = &quot;unset&quot;)</code></pre><p>程序启动时，会将这些变量打到日志中。</p><p><code>main.go</code></p><pre><code class="go">...func main() &#123;    log.Printf(        &quot;Starting the service...\ncommit: %s, build time: %s, release: %s&quot;,        version.Commit, version.BuildTime, version.Release,    )...&#125;</code></pre><p>也可以把这些信息添加到<code>home</code>handler中（别忘了更新对应的测试方法）：</p><p><code>handlers/home.go</code></p><pre><code class="go">package handlersimport (    &quot;encoding/json&quot;    &quot;log&quot;    &quot;net/http&quot;    &quot;github.com/rumyantseva/advent-2017/version&quot;)// home is a simple HTTP handler function which writes a response.func home(w http.ResponseWriter, _ *http.Request) &#123;    info := struct &#123;        BuildTime string `json:&quot;buildTime&quot;`        Commit    string `json:&quot;commit&quot;`        Release   string `json:&quot;release&quot;`    &#125;&#123;        version.BuildTime, version.Commit, version.Release,    &#125;    body, err := json.Marshal(info)    if err != nil &#123;        log.Printf(&quot;Could not encode info data: %v&quot;, err)        http.Error(w, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)        return    &#125;    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)    w.Write(body)&#125;</code></pre><p>通过Go链接器在编译时设置<code>BuildTime</code>，<code>Commit</code>以及<code>Release</code>变量。</p><p>先在Makefile中添加新变量：</p><p><code>Makefile</code></p><pre><code>RELEASE?=0.0.1COMMIT?=$(shell git rev-parse --short HEAD)BUILD_TIME?=$(shell date -u &#39;+%Y-%m-%d_%H:%M:%S&#39;)</code></pre><p><code>COMMIT</code>和<code>BUILD_TIME</code>（译者注：原文这里写<code>RELEASE</code>，可能有误）通过已有的命令获取，<code>RELEASE</code>的赋值按照<a href="https://dave.cheney.net/2016/06/24/gophers-please-tag-your-releases">语义化版本控制规范</a>来。</p><p>好，现在重写Makefile的<code>build</code>目标，用上上面定义的变量：</p><p><code>Makefile</code></p><pre><code>build: clean    go build \        -ldflags &quot;-s -w -X $&#123;PROJECT&#125;/version.Release=$&#123;RELEASE&#125; \        -X $&#123;PROJECT&#125;/version.Commit=$&#123;COMMIT&#125; -X $&#123;PROJECT&#125;/version.BuildTime=$&#123;BUILD_TIME&#125;&quot; \        -o $&#123;APP&#125;</code></pre><p>将<code>PROJECT</code>变量添加到<code>Makefile</code>开头地方（减少多处定义）。</p><p><code>Makefile</code></p><pre><code>PROJECT?=github.com/rumyantseva/advent-2017</code></pre><p>本步所有代码变更记录可以在<a href="https://github.com/rumyantseva/advent-2017/commit/eaa4ff224b32fb343f5eac2a1204cc3806a22efd">这里</a>找到。可以多动手尝试运行下<code>make run</code>命令，看看具体是怎么工作的。</p><h2 id="第八步-减少依赖"><a href="#第八步-减少依赖" class="headerlink" title="第八步 减少依赖"></a>第八步 减少依赖</h2><p>之前代码有个不尽如人意的点：<code>handler</code>包依赖<code>version</code>包。做个简单的改动，让<code>home</code>处理器变成可配置的，减少依赖：</p><p><code>handlers/home.go</code></p><pre><code class="go">// home returns a simple HTTP handler function which writes a response.func home(buildTime, commit, release string) http.HandlerFunc &#123;    return func(w http.ResponseWriter, _ *http.Request) &#123;        ...    &#125;&#125;</code></pre><p>同样，别忘了<a href="https://github.com/rumyantseva/advent-2017/commit/e73b996f8522b736c150e53db059cf041c7c3e64">改</a>测试代码。</p><h2 id="第九步-添加“健康”检查功能（health-checks）"><a href="#第九步-添加“健康”检查功能（health-checks）" class="headerlink" title="第九步 添加“健康”检查功能（health checks）"></a>第九步 添加“健康”检查功能（health checks）</h2><p>某些情况下，想在kubernetes上跑服务，需要添加“健康”检查功能: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">liveness和readiness检测</a>。liveness检测目的是测试程序是否还在跑。如果liveness检测失败，服务会被重启。readiness检测目的是测试程序是否准备好可以接受请求。如果readiness检测失败，该容器会从服务负载均衡器中移除。</p><p>实现liveness检测的方式，可以简单写一个handler返回<code>200</code>:</p><p><code>handlers/healthz.go</code></p><pre><code class="go">// healthz is a liveness probe.func healthz(w http.ResponseWriter, _ *http.Request) &#123;    w.WriteHeader(http.StatusOK)&#125;</code></pre><p>readiness检测实现方式类似，不同的就是可能要等待某事件完成（例如：数据库已起来）：</p><p><code>handlers/readyz.go</code></p><pre><code class="go">// readyz is a readiness probe.func readyz(isReady *atomic.Value) http.HandlerFunc &#123;    return func(w http.ResponseWriter, _ *http.Request) &#123;        if isReady == nil || !isReady.Load().(bool) &#123;            http.Error(w, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)            return        &#125;        w.WriteHeader(http.StatusOK)    &#125;&#125;</code></pre><p>当<code>isReady</code>有值并且为<code>true</code>，返回<code>200</code>。</p><p>例子如下：</p><p><code>handlers.go</code></p><pre><code class="go">func Router(buildTime, commit, release string) *mux.Router &#123;    isReady := &amp;atomic.Value&#123;&#125;    isReady.Store(false)    go func() &#123;        log.Printf(&quot;Readyz probe is negative by default...&quot;)        time.Sleep(10 * time.Second)        isReady.Store(true)        log.Printf(&quot;Readyz probe is positive.&quot;)    &#125;()    r := mux.NewRouter()    r.HandleFunc(&quot;/home&quot;, home(buildTime, commit, release)).Methods(&quot;GET&quot;)    r.HandleFunc(&quot;/healthz&quot;, healthz)    r.HandleFunc(&quot;/readyz&quot;, readyz(isReady))    return r&#125;</code></pre><p>设置等待10s后服务可以处理请求。当然，实际业务代码不会有空等10s的情况，这里是模拟cache warming（如果有用cache）或者其他情况。</p><p>代码改动<a href="https://github.com/rumyantseva/advent-2017/commit/e73b996f8522b736c150e53db059cf041c7c3e64">GitHub</a>上可以找到。</p><p>注意：如果流量过大，服务节点的响应会不稳定。例如，liveness检测会因为超时失败。这就是为什么一些工程师不用liveness检测的原因。个人认为，当发现请求越来越多时候，最好是去扩容；例如可以参考<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">scale pods with HPA</a>。</p><h2 id="第十步-添加平滑关闭功能"><a href="#第十步-添加平滑关闭功能" class="headerlink" title="第十步 添加平滑关闭功能"></a>第十步 添加平滑关闭功能</h2><p>关闭服务时，最好是不要立即中断连接、请求或者其他一些操作，而应该平滑关闭。Go从1.8版本支持平滑关闭<code>http.Server</code>。下面看看怎么用：</p><p><code>main.go</code></p><pre><code class="go">func main() &#123;    ...    r := handlers.Router(version.BuildTime, version.Commit, version.Release)    interrupt := make(chan os.Signal, 1)    signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)    srv := &amp;http.Server&#123;        Addr:    &quot;:&quot; + port,        Handler: r,    &#125;    go func() &#123;        log.Fatal(srv.ListenAndServe())    &#125;()    log.Print(&quot;The service is ready to listen and serve.&quot;)    killSignal := &lt;-interrupt    switch killSignal &#123;    case os.Interrupt:        log.Print(&quot;Got SIGINT...&quot;)    case syscall.SIGTERM:        log.Print(&quot;Got SIGTERM...&quot;)    &#125;    log.Print(&quot;The service is shutting down...&quot;)    srv.Shutdown(context.Background())    log.Print(&quot;Done&quot;)&#125;</code></pre><p>收到<code>SIGINT</code>或<code>SIGTERM</code>任意一个系统信号，服务平滑关闭。</p><p>注意：这段代码的旧版本，尝试去捕获<code>SIGKILL</code>信号。之前在不同的库中有看到过这种用法，我（作者）确认这样是行的通的。但是后来Sandor Szücs<a href="https://twitter.com/sszuecs/status/941582509565005824">指出</a>，不可能获取到<code>SIGKILL</code>信号。发出<code>SIGKILL</code>信号后，程序会直接结束。</p><h2 id="第十一步-添加Dockerfile"><a href="#第十一步-添加Dockerfile" class="headerlink" title="第十一步 添加Dockerfile"></a>第十一步 添加Dockerfile</h2><p>程序基本上可以在Kubernetes上跑了。这一步进行docker化。</p><p>先添加一个简单的<code>Dockerfile</code>，如下：</p><p><code>Dockerfile</code>：</p><pre><code>FROM scratchENV PORT 8000EXPOSE $PORTCOPY advent /CMD [&quot;/advent&quot;]</code></pre><p>创建了一个最小的容器，复制二进制到容器内然后运行（别忘了<code>PORT</code>配置变量）。</p><p>扩展<code>Makefile</code>，使其能够构建镜像以及运行容器。同时添加<code>GOOS</code>和<code>GOARCH</code>变量，在<code>build</code>goal中交叉编译要用到。</p><p><code>Makefile</code></p><pre><code>...GOOS?=linuxGOARCH?=amd64...build: clean    CGO_ENABLED=0 GOOS=$&#123;GOOS&#125; GOARCH=$&#123;GOARCH&#125; go build \        -ldflags &quot;-s -w -X $&#123;PROJECT&#125;/version.Release=$&#123;RELEASE&#125; \        -X $&#123;PROJECT&#125;/version.Commit=$&#123;COMMIT&#125; -X $&#123;PROJECT&#125;/version.BuildTime=$&#123;BUILD_TIME&#125;&quot; \        -o $&#123;APP&#125;container: build    docker build -t $(APP):$(RELEASE) .run: container    docker stop $(APP):$(RELEASE) || true &amp;&amp; docker rm $(APP):$(RELEASE) || true    docker run --name $&#123;APP&#125; -p $&#123;PORT&#125;:$&#123;PORT&#125; --rm \        -e &quot;PORT=$&#123;PORT&#125;&quot; \        $(APP):$(RELEASE)...</code></pre><p>添加了<code>container</code>和<code>run</code>goal，前者构建镜像，后者从容器启动程序。所有改动<a href="https://github.com/rumyantseva/advent-2017/commit/909fef6d585c85c5e16b5b0e4fdbdf080893b679">这里</a>可以找到。</p><p>请尝试运行<code>make run</code>命令，检查所有过程是否正确。</p><h2 id="第十二步-添加vendor"><a href="#第十二步-添加vendor" class="headerlink" title="第十二步 添加vendor"></a>第十二步 添加vendor</h2><p>项目中依赖了外部代码（<a href="github.com/gorilla/mux">github.com&#x2F;gorilla&#x2F;mux</a>），所以肯定要<a href="https://github.com/rumyantseva/advent-2017/commit/7ffa56a78400367e5d633521dee816b767d7d05d">加入依赖管理</a>。如果引入<code>dep</code>的话，就只要执行<code>dep init</code>：</p><pre><code>$ dep init  Using ^1.6.0 as constraint for direct dep github.com/gorilla/mux  Locking in v1.6.0 (7f08801) for direct dep github.com/gorilla/mux  Locking in v1.1 (1ea2538) for transitive dep github.com/gorilla/context</code></pre><p>会创建<code>Gopkg.toml</code>和<code>Gopkg.lock</code>文件以及<code>vendor</code>目录。个人观点，推荐push<code>vendor</code>到git，重要的项目尤其应该push上去。</p><h2 id="第十三步-Kubernetes"><a href="#第十三步-Kubernetes" class="headerlink" title="第十三步 Kubernetes"></a>第十三步 Kubernetes</h2><p><a href="https://github.com/rumyantseva/advent-2017/commit/27b256191dc8d4530c895091c49b8a9293932e0f">最后一步</a>，将程序部署到Kubernets上运行。本地环境最简单方式就是安装、配置<a href="https://github.com/kubernetes/minikube">minikube</a>。</p><p>Kubernetes从Docker registry拉取镜像。本文中，使用公共Docker registry–<a href="https://hub.docker.com/">Docker Hub</a>。<code>Makefile</code>中还要添加一个变量和命令：</p><pre><code>CONTAINER_IMAGE?=docker.io/webdeva/$&#123;APP&#125;...container: build    docker build -t $(CONTAINER_IMAGE):$(RELEASE) ....push: container    docker push $(CONTAINER_IMAGE):$(RELEASE)</code></pre><p><code>CONTAINER_IMAGE</code>变量定义了push、pull镜像的Docker registry repo，路径中包含了用户名（webdeva）。如果没有<a href="hub.docker.com">hub.docker.com</a>账户，请创建账户并通过<code>docker login</code>登录。这样就可以push镜像了。</p><p>运行<code>make push</code>：</p><pre><code>$ make push...docker build -t docker.io/webdeva/advent:0.0.1 .Sending build context to Docker daemon   5.25MB...Successfully built d3cc8f4121feSuccessfully tagged webdeva/advent:0.0.1docker push docker.io/webdeva/advent:0.0.1The push refers to a repository [docker.io/webdeva/advent]ee1f0f98199f: Pushed0.0.1: digest: sha256:fb3a25b19946787e291f32f45931ffd95a933100c7e55ab975e523a02810b04c size: 528</code></pre><p>成功了~！然后可以在<a href="https://hub.docker.com/r/webdeva/advent/tags/">这里找到镜像</a>。</p><p>接下来，定义必要的Kubernetes配置（manifest）。通常，一个服务至少需要设置deployment、service和ingress配置。默认情况，manifest都是静态的，即其中不能使用任何变量。不过可以通过<a href="https://github.com/kubernetes/helm">helm工具</a>创建更灵活的配置。</p><p>本文中，没有用<code>helm</code>，定义了两个变量：<code>ServiceName</code>和<code>Release</code>，灵活性更高些。后面通过<code>sed</code>命令替换“变量”为实际值。</p><p>先看下deployment配置：<br><code>deployment.yaml</code></p><pre><code>apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: &#123;&#123; .ServiceName &#125;&#125;  labels:    app: &#123;&#123; .ServiceName &#125;&#125;spec:  replicas: 3  strategy:    type: RollingUpdate    rollingUpdate:      maxUnavailable: 50%      maxSurge: 1  template:    metadata:      labels:        app: &#123;&#123; .ServiceName &#125;&#125;    spec:      containers:      - name: &#123;&#123; .ServiceName &#125;&#125;        image: docker.io/webdeva/&#123;&#123; .ServiceName &#125;&#125;:&#123;&#123; .Release &#125;&#125;        imagePullPolicy: Always        ports:        - containerPort: 8000        livenessProbe:          httpGet:            path: /healthz            port: 8000        readinessProbe:          httpGet:            path: /readyz            port: 8000        resources:          limits:            cpu: 10m            memory: 30Mi          requests:            cpu: 10m            memory: 30Mi      terminationGracePeriodSeconds: 30</code></pre><p>Kubernetes的配置要讲清楚可以单独写一篇文章了，这里用到了容器镜像和liveness、readiness检测功能，去哪里找镜像，以及检测模块的路径前文都有阐述。</p><p>一个经典的服务更简单：</p><p><code>service.yaml</code></p><pre><code>apiVersion: v1kind: Servicemetadata:  name: &#123;&#123; .ServiceName &#125;&#125;  labels:    app: &#123;&#123; .ServiceName &#125;&#125;spec:  ports:  - port: 80    targetPort: 8000    protocol: TCP    name: http  selector:    app: &#123;&#123; .ServiceName &#125;&#125;</code></pre><p>最后，定义下ingress。定义从外部访问访问Kubernetes中服务的规则。这里假定把服务“attach”到<code>advent.test</code>域上（实际不是）。</p><p><code>ingress.yaml</code></p><pre><code>apiVersion: extensions/v1beta1kind: Ingressmetadata:  annotations:    kubernetes.io/ingress.class: nginx    ingress.kubernetes.io/rewrite-target: /  labels:    app: &#123;&#123; .ServiceName &#125;&#125;  name: &#123;&#123; .ServiceName &#125;&#125;spec:  backend:    serviceName: &#123;&#123; .ServiceName &#125;&#125;    servicePort: 80  rules:  - host: advent.test    http:      paths:      - path: /        backend:          serviceName: &#123;&#123; .ServiceName &#125;&#125;          servicePort: 80</code></pre><p>验证配置是否正确，需要安装、运行<code>minikube</code>，官方文档在<a href="https://github.com/kubernetes/minikube#installation">这里</a>，还需要安装<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">kubectl</a>工具，用来提供配置和检验服务。</p><p>启动<code>minikube</code>，<code>ingress</code>，<code>kubectl</code>命令如下：</p><pre><code>minikube startminikube addons enable ingresskubectl config use-context minikube</code></pre><p>接下来，给<code>Makefile</code>添加新goal：安装服务到<code>minikube</code>上。</p><p><code>Makefile</code></p><pre><code>minikube: push    for t in $(shell find ./kubernetes/advent -type f -name &quot;*.yaml&quot;); do \        cat $$t | \            gsed -E &quot;s/\&#123;\&#123;(\s*)\.Release(\s*)\&#125;\&#125;/$(RELEASE)/g&quot; | \            gsed -E &quot;s/\&#123;\&#123;(\s*)\.ServiceName(\s*)\&#125;\&#125;/$(APP)/g&quot;; \        echo ---; \    done &gt; tmp.yaml    kubectl apply -f tmp.yaml</code></pre><p>上面命令“编译”所有<code>*.yaml</code>配置到一个文件。用实际值替换<code>Release</code>和<code>ServiceName</code>变量（注意，这里用了<code>gsed</code>而非标准<code>sed</code>）,最后运行<code>kubectl apply</code>命令安装应用到Kubernetes上。</p><p>验证配置是否正确：</p><pre><code>$ kubectl get deploymentNAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGEadvent    3         3         3            3           1d$ kubectl get serviceNAME         CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGEadvent       10.109.133.147   &lt;none&gt;        80/TCP    1d$ kubectl get ingressNAME      HOSTS         ADDRESS        PORTS     AGEadvent    advent.test   192.168.64.2   80        1d</code></pre><p>先在<code>/etc/host</code>文件添加模拟域名<code>advent.test</code>，然后可以发请求测试服务了。</p><pre><code>echo &quot;$(minikube ip) advent.test&quot; | sudo tee -a /etc/hosts</code></pre><pre><code>curl -i http://advent.test/homeHTTP/1.1 200 OKServer: nginx/1.13.6Date: Sun, 10 Dec 2017 20:40:37 GMTContent-Type: application/jsonContent-Length: 72Connection: keep-aliveVary: Accept-Encoding&#123;&quot;buildTime&quot;:&quot;2017-12-10_11:29:59&quot;,&quot;commit&quot;:&quot;020a181&quot;,&quot;release&quot;:&quot;0.0.5&quot;&#125;%</code></pre><p>成功~！</p><hr><p>via: <a href="https://blog.gopheracademy.com/advent-2017/kubernetes-ready-service/">https://blog.gopheracademy.com/advent-2017/kubernetes-ready-service/</a></p><p>作者：<a href="https://github.com/jeffallen">Elena Grahovac</a><br>译者：<a href="https://github.com/dongfengkuayue">dongfengkuayue</a><br>校对：<a href="https://github.com/%E6%A0%A1%E5%AF%B9%E8%80%85ID">校对者ID</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go 中文网</a> 荣誉推出</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO reflection理解</title>
      <link href="/2017/08/01/go_reflection/"/>
      <url>/2017/08/01/go_reflection/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Golang是静态类型的，每个变量都有一个静态类型，如int，float32，*MyType，[]byte等，静态类型在编译时刻就确定了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure><p>上面<code>i</code>和<code>j</code>的底层类型是相同的，都是int，但是它们的静态类型不同，它们之间要互相赋值的话要显示转换。</p><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p><code>interface</code>类型的本质代表的是包含了一组固定方法的类型，所以该型变量可以保存任何实现了那组固定方法的变量；<br>而<code>空interface</code>：<code>interface&#123;&#125;</code>，表示其固定方法集合为空，由于任何变量都有0或者大于0个方法，故而<code>空interface</code>可以保存任何一种类型的变量。</p><h2 id="interface本质"><a href="#interface本质" class="headerlink" title="interface本质"></a>interface本质</h2><p><code>interface</code>本质上存储了一个pair：<code>(value,concrete type)</code>，即一个实现了接口的底层具体值<code>value</code>和具体类型<code>concrete type</code><br>例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure><p>r接口类型变量中存储的就是(tty, *os.File)，而非(tty,io.Reader)，接口存储的类型总是变量原本的类型i，而非对应的接口类型。<br>接口底层存储变量提供的方法也可能会比接口中定义的方法要多，例如os.File类型还实现了Write方法，而r对应的接口类型只有Read方法。</p><h1 id="静态类型与底层类型"><a href="#静态类型与底层类型" class="headerlink" title="静态类型与底层类型"></a>静态类型与底层类型</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.ValueOf(x).Type())</span><br><span class="line">fmt.Println(reflect.ValueOf(x).Kind())</span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.TypeOf(x))</span><br><span class="line">fmt.Println(reflect.TypeOf(x).Kind())</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.MyInt</span><br><span class="line">int</span><br><span class="line">main.MyInt</span><br><span class="line">int</span><br></pre></td></tr></table></figure><p>可以区分出来<code>Type()</code>是获取静态类型，<code>Kind()</code>获取底层类型</p><h1 id="一组互逆操作"><a href="#一组互逆操作" class="headerlink" title="一组互逆操作"></a>一组互逆操作</h1><p><code>Interface()</code>和<code>ValueOf()</code>操作：后者将<code>interface&#123;&#125;</code>类型转为<code>reflect.Value</code>类型，前者是后者的逆操作</p><h1 id="获取成员变量、方法"><a href="#获取成员变量、方法" class="headerlink" title="获取成员变量、方法"></a>获取成员变量、方法</h1><p>官方例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="type">int</span></span><br><span class="line">    B <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := T&#123;<span class="number">23</span>, <span class="string">&quot;skidoo&quot;</span>&#125;</span><br><span class="line">s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">typeOfT := s.Type()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">    f := s.Field(i)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d: %s %s = %v\n&quot;</span>, i,</span><br><span class="line">        typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，通过反射获取到的成员变量本身是常规的<code>reflect.Value</code>对象，而成员变量的名称需要通过struct的<code>reflect.Type</code>映射对象获取</p><h1 id="反射三定律"><a href="#反射三定律" class="headerlink" title="反射三定律"></a>反射三定律</h1><p>Golang官网总结了反射的三大定律（原则）：</p><ul><li>反射可以将<code>interface</code>类型值转为<code>reflection object</code></li><li>反射可以将<code>reflection object</code>转为<code>interface</code>类型值</li><li>要通过<code>reflection object</code>改变原始值，变量必须是可设置的（settable）</li></ul><p>前两条强调的是，<code>reflect.Value</code>和<code>reflect.Type</code>只会和<code>interface</code>类型变量做转换，并且它们之间是可以互相转的。<br>其中可设置，我的理解就是传参时候要<strong>传指针</strong>，因为golang默认是传值的；</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type of p:&quot;</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of p:&quot;</span>, p.CanSet())</span><br></pre></td></tr></table></figure><p>注意这里得到的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type of p: *float64</span><br><span class="line">settability of p: false</span><br></pre></td></tr></table></figure><p>反射对象p不可设置，但是我们要设置的不是<code>p</code>，而是<code>*p</code>，需要调用<code>Elem</code>取得<code>p</code>指向的内容。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v := p.Elem()</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settability of v: true</span><br></pre></td></tr></table></figure><p>个人感觉golang中的反射，如果传入的是一个指针，那么想要作用到指针所指向的变量，如获取变量的<code>Type</code>、设置变量的值等，那么先要调用<code>Elem</code>或者<code>Indirect</code>方法，获取真正代表变量的反射对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>江南天池旅游</title>
      <link href="/2017/07/26/jiangnan_tianchi_lvyou/"/>
      <url>/2017/07/26/jiangnan_tianchi_lvyou/</url>
      
        <content type="html"><![CDATA[<p>正值暑期最热的几天，我租了个车去了江南天池。<br>江南天池位于浙江安吉天荒坪，说是天池，其实就是建在山顶的水库。<br><img src="/images/tianchi.jpeg" alt="天池水库"><br>我早晨从上海出发，中午到达了苏州，然后沿着靠太湖的一条国道开了过去，之所以没有开高速，是因为刚拿到驾照不久，一来对自己的技术还有点疑虑，而来因为还在实习期确实不能上高速。到达天池山脚下已经傍晚了，找了家旅馆就睡下了。农家旅舍条件很一般，加上天气炎热，一路奔波，反而有点头疼。<br>第二天开车上山，全是盘山公路，倒是很有驾驶乐趣，上海哪有这种路线。<br>到达天池，就有点后悔了，因为是山顶水库，全是钢筋混凝土构造的人工奇迹，一点树木没有，所以特别特别的晒，热的直流汗，我们绕着水库溜达了一圈就下去了，其他也有些游客也跟我们一样，没逛两圈就回去了。<br>夏天建议去海拔稍微高一点的地方去爬山，低海拔的地方爬山就跟桑拿无异。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
